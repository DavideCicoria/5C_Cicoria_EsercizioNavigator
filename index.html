<!DOCTYPE html>
<html lang="en">

<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet"
      type="text/css" />
   <link rel="stylesheet" type="text/css" href="./style.css" />
   <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.min.js"></script>
   <title>SPA semplice</title>
</head>

<body>
   <div id="container" class="container">
      <div id="pagina1" class="page spazio">
         <div class="row"><div><h1>Stack</h1>
            <div id="eckb-article-content-body"><h2 class="wp-block-heading" id="block-70b03cf11ed84660b1af4c7362a56811" data-id="articleTOC_0"><strong>Il modello di memoria della macchina di Von Neumann</strong></h2>
            
            
            
                <figure class="wp-block-image" id="block-07ba17f9aa83477aa1fb982c3067d83e"><img decoding="async" src="https://imagedelivery.net/IEMzXmjRvW0g933AN5ejrA/wwwnotionso-image-prod-files-secures3us-west-2amazonawscom-54c12d55-229f-4c83-b4b6-dd7d262e4443-5b0e905a-c592-41e1-8028-1a8206f05412-untitledpng/public" alt="notion image"></figure>
                
                
                
                <p>Nella macchina di Von Neumann, la memoria è organizzata come un grosso array, ovvero una sequenza di celle ciascuna con un indirizzo assoluto (da 0 alla memoria massima allocabile). La memoria massima logica di un programma è in genere data dalla sua <span class="glossaryLink" aria-describedby="tt" data-cmtooltip="<div class=glossaryItemTitle>Architettura</div><div class=glossaryItemBody>&amp;lt;!-- wp:paragraph --&amp;gt;L&amp;#039;architettura di un sistema informatico indica il modo in cui è organizzato il software, di quali componenti e moduli è composto, che ruolo hanno e in che modo comunicano.&amp;lt;br/&amp;gt;&amp;lt;!-- /wp:paragraph --&amp;gt;</div>" data-gt-translate-attributes="[{&quot;attribute&quot;:&quot;data-cmtooltip&quot;, &quot;format&quot;:&quot;html&quot;}]" tabindex="0" role="link">architettura</span>: i primi computer potevano avere pochi K di memoria, quelli moderni arrivano a decine di GB.</p>
                
                
                
                <p><strong>La memoria è unica e</strong><strong>contiene sia le istruzioni che i dati</strong>, cioè le variabili, le strutture dati, i dati di input/ouput ed ogni dato di elaborazione del programma.</p>
                
                
                
                <p>In molte implementazioni il&nbsp;<strong>codice</strong>&nbsp;viene memorizzato nella parte bassa della memoria, e ciò avviene al caricamento del programma in memoria (da parte del sistema operativo).</p>
                
                
                
                <p>Il programma in esecuzione ha pieno accesso alla memoria, e quindi può leggere e scrivere in qualsiasi locazione di memoria, conoscendone il solo indirizzo, cioè la posizione in memoria. I programmi scritti in linguaggio ad alto livello hanno comunque meccanismi di protezione della memoria, e quando vengono eseguiti forniscono al programmatore direttamente l’accesso a variabili e tipi di dato (numeri, stringhe, liste, ecc.).</p>
                
                
                
                <p>Internamente però queste variabili vengono memorizzate nell’area di memoria immediatamente “sopra” al codice, che viene chiamata “<strong>heap</strong>” (cumulo). Il programma alloca dello spazio in memoria, in base alle dimensioni delle strutture dati da utilizzare e agli algoritmi previsti da quel linguaggio ad alto livello (ad es. Java o Python).</p>
                
                
                
                <p>La memoria “in alto” invece viene utilizzata per memorizzare le chiamate ai&nbsp;<strong>sottoprogrammi</strong>&nbsp;(detti anche subroutine). I sottoprogrammi sono parti di un programma che possono essere eseguite più volte in parti diverse del programma. Essi in genere svolgono compiti di utilità e semplificano lo sviluppo di software, evitando di ripetere di scrivere lo stesso codice. Nei linguaggi ad alto livello sono chiamati in genere “funzioni”.</p>
                
                
                
                <p>Qui un esempio di chiamata di funzione (somma tra loro tutti gli interi compresi tra 1 a n):</p>
                
                
                
                <div class="hcb_wrap"><pre class="prism line-numbers  language-cpp" data-lang="C++"><code class=" language-cpp" data-hcb-clip="1"><span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                  <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    result <span class="token operator">+=</span> i<span class="token punctuation">;</span>
                  <span class="token punctuation">}</span>
                  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                 
                <span class="token keyword">int</span> s <span class="token operator">=</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><button class="hcb-clipboard" data-clipboard-target="[data-hcb-clip=&quot;1&quot;]" data-clipboard-action="copy" aria-label="Copy code to clipboard"></button></div>
                
                
                
                <p>Nella chiamata al sottoprogramma, il chiamante cede il controllo alla funzione del sottoprogramma, a cui passa eventualmente dei parametri. Alla fine tuttavia il chiamato deve restituire il controllo al chiamante, facendo eseguire l’istruzione successiva alla chiamata.</p>
                
                
                
                <figure class="wp-block-image" id="block-929ded3786d64415afdf987c3388c237"><img decoding="async" src="https://imagedelivery.net/IEMzXmjRvW0g933AN5ejrA/wwwnotionso-image-prod-files-secures3us-west-2amazonawscom-54c12d55-229f-4c83-b4b6-dd7d262e4443-7ba4473c-3f42-49c4-8b2e-fbb26e19d0d0-untitledpng/public" alt="notion image"></figure>
                
                
                
                <p>Per poter eseguire quindi le chiamate ai sottoprogrammi occorre un “meccanismo” che memorizzi sia&nbsp;<strong>l’indirizzo di ritorno</strong>&nbsp;della chiamata, sia i&nbsp;<strong>parametri</strong>&nbsp;o argomenti che questi possono ricevere. Inoltre se sono presenti vanno memorizzati anche eventuali&nbsp;<strong>valori di ritorno</strong>.</p>
                
                
                
                <p>Queste informazioni&nbsp;non si possono mettere in una posizione fissa della memoria, perchè anche un sottoprogramma ne può chiamare a sua volta un altro, e quindi deve poter anche lui memorizzare indirizzi di ritorno, parametri in ingresso e valori di ritorno. E’ necessaria una struttura dati dinamica, in memoria, che memorizzi queste informazioni, e che allo stesso tempo sia facile e veloce da utilizzare.</p>
                
                
                
                <p>Questo problema venne risolto brillantemente da Von Neumann facendo ricorso allo&nbsp;<strong>stack</strong>, una struttura matematica che si usa in programmazione.</p>
                
                
                
                <p>Vediamo di che si tratta.</p>
                
                
                
                <h2 class="wp-block-heading" id="block-982ff8432f894ad986b717d5ab3e7f30" data-id="articleTOC_1"><strong>Cos’è lo stack?</strong></h2>
                
                
                
                <p>Lo stack (“pila”) è una struttura dati matematica che si usa in informatica per memorizzare liste di elementi secondo il principio LIFO (Last In First Out). In altri termini l’accesso alla pila è solo tramite l’ultimo elemento e le due uniche operazioni possibili sono:</p>
                
                
                
                <ul class="wp-block-list" id="block-e30979bd09104a148dcc2907c2523ac3">
                <li><strong>push</strong>: aggiunta di un elemento</li>
                
                
                
                <li><strong>pop</strong>: estrazione di un elemento e sua rimozione</li>
                </ul>
                
                
                
                <p>Esempio: ipotizziamo di avere all’inizio uno stack vuoto (nessun elemento). Se eseguiamo PUSH (5) avremo:</p>
                
                
                
                <figure class="wp-block-image" id="block-d31167b3d2894a8e91c06d5da13c4956"><img decoding="async" src="https://imagedelivery.net/IEMzXmjRvW0g933AN5ejrA/wwwnotionso-image-prod-files-secures3us-west-2amazonawscom-54c12d55-229f-4c83-b4b6-dd7d262e4443-a285551c-fc09-4067-a3e5-eb7f18db4362-untitledpng/public" alt="notion image"></figure>
                
                
                
                <p>Lo stack contiene un solo elemento. Se eseguiamo una PUSH(7) avremo:</p>
                
                
                
                <figure class="wp-block-image" id="block-902dbdb2914e419cafd6a2c59748f3ff"><img decoding="async" src="https://imagedelivery.net/IEMzXmjRvW0g933AN5ejrA/wwwnotionso-image-prod-files-secures3us-west-2amazonawscom-54c12d55-229f-4c83-b4b6-dd7d262e4443-dfd007f7-0838-480f-8fd4-ff2dee3d1747-untitledpng/public" alt="notion image"></figure>
                
                
                
                <p>Ora sono due elementi. Se aggiungiamo ancora il valore 4&nbsp;&nbsp;con PUSH(4) avremo:</p>
                
                
                
                <figure class="wp-block-image" id="block-2dc42df7eb504f1b9a86ace70e58fc07"><img decoding="async" src="https://imagedelivery.net/IEMzXmjRvW0g933AN5ejrA/wwwnotionso-image-prod-files-secures3us-west-2amazonawscom-54c12d55-229f-4c83-b4b6-dd7d262e4443-4ae1974e-9d7b-4ac3-af4a-2dbeaef964c3-untitledpng/public" alt="notion image"></figure>
                
                
                
                <p>E così via. Ma attenzione, se eseguiamo POP() estrarremo l’ultimo valore (cioè 4) e rimarrà:</p>
                
                
                
                <figure class="wp-block-image" id="block-cc0c423e06194139903d3e61c50b4b47"><img decoding="async" src="https://imagedelivery.net/IEMzXmjRvW0g933AN5ejrA/wwwnotionso-image-prod-files-secures3us-west-2amazonawscom-54c12d55-229f-4c83-b4b6-dd7d262e4443-3bfdf2cd-90ef-4ca7-b2b7-5ceee4bb2c41-untitledpng/public" alt="notion image"></figure>
                
                
                
                <p>La macchina di Von Neumann prevede un registro della CPU che si chiama&nbsp;<strong>SP</strong>&nbsp;(“stack pointer”) che contiene l’indirizzo dell’ultima cella dello stack.</p>
                
                
                
                <p>Quando un programma (o sottoprogramma) ha bisogno di chiamare un sottoprogramma, memorizza nello stack :</p>
                
                
                
                <p>1)&nbsp;<strong>indirizzo di ritorno</strong>&nbsp;(PUSH)</p>
                
                
                
                <p>2)&nbsp;<strong>parametri</strong>&nbsp;opzionali (PUSH)</p>
                
                
                
                <p>E poi chiama (nella CPU si modifica il PC) il sottoprogramma.</p>
                
                
                
                <p>Il sottoprogramma esegue la sua attività, SENZA conoscere informazioni sul chiamante, ma lavorando solo sui parametri presenti nello stack.</p>
                
                
                
                <p>Al termine della sua esecuzione (quando cioè viene richiamato “return”):</p>
                
                
                
                <p>3)&nbsp;<strong>estrae</strong>&nbsp;ed&nbsp;<strong>elimina</strong>&nbsp;i&nbsp;<strong>parametri</strong>&nbsp;(POP)</p>
                
                
                
                <p>4)&nbsp;<strong>estrae indirizzo di ritorno</strong>&nbsp;(POP)</p>
                
                
                
                <p>5)&nbsp;<strong>aggiunge eventuali valori di ritorno</strong>&nbsp;(PUSH)</p>
                
                
                
                <p>6) modifica il PC e quindi l’istruzione successiva sarà quella successiva del chiamante.</p>
                
                
                
                <p>Il chiamante:</p>
                
                
                
                <p>7)&nbsp;<strong>estrae il valore di ritorno dallo stack</strong>&nbsp;(se presente) (POP)</p>
                
                
                
                <p>Lo stack (acceduto mediante SP) è quindi un meccanismo che permette di:</p>
                
                
                
                <ul class="wp-block-list" id="block-fd81cfc2da0748ee8c4e900615e52a80">
                <li>scambiare dati tra chiamante e chiamato;</li>
                
                
                
                <li>memorizzare dati&nbsp;e poterli cancellare dinamicamente quando non servono più, partendo dal più recente;</li>
                
                
                
                <li>siccome è una pila, ogni procedura in esecuzione può a sua volta chiamare delle sottoprocedure.</li>
                </ul>
                
                
                
                <p>La limitazione dello stack è ovviamente data dalla dimensione della memoria: se la memoria dello stack occupa memoria fino ad arrivare a raggiungere lo heap, succede una problematica che si chiama “stack overflow”. Di solito all’avvio del programma viene memorizzato un limite superiore alla dimensione dello stack proprio per evitare questo tipo di problema, ed alcune architetture prevedono un riconoscimento hardware.</p>
                
                
                
                <p>Qui sotto lo schema riassuntivo che mostra cosa succede allo stack in una tipica chiamata di sottoprogramma.</p>
                
                
                
                <figure class="wp-block-image" id="block-8a316f08310a42f3b03661c5fb080f96"><img decoding="async" src="https://imagedelivery.net/IEMzXmjRvW0g933AN5ejrA/wwwnotionso-image-prod-files-secures3us-west-2amazonawscom-54c12d55-229f-4c83-b4b6-dd7d262e4443-01bf541c-698d-4d57-afb1-3904d6e29e1c-untitledpng/public" alt="notion image"></figure>
               </div>
            </div>
         </div>
         <div class="row"><a href="#pagina2"><button type="button" id="pag2div1" class="btn btn-primary">Pagina 2 (Codice Assembly)</button></a></div>
         <div class="row"><a href="#pagina3"><button type="button" id="pag3div1" class="btn btn-primary">Pagina 3 (Semafori)</button></a></div>                  
   </div>
   <div id="pagina2" class="page spazio">
      <div class="row"></div>   
      <div class="row"><a href="#pagina1">Questo è un link a pagina 1</a></div>
      <div class="row"><a href="#pagina3">Questo è un link a pagina 3</a></div>                  
   </div>
   <div id="pagina3" class="page spazio">
      <div class="row">Questo è il contenuto di pagina 3</div> 
      <div class="row"><a href="#pagina1">Questo è un link a pagina 1</a></div>
      <div class="row"><a href="#pagina2">Questo è un link a pagina 2</a></div>
   </div>

      <a href="../index.html"><button type="button" id="home" class="btn btn-success">Home</button></a>
      
   </div>
   <script type="module" src="./index.js"></script>

</body>

</html>