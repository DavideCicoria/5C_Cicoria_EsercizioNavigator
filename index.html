<!DOCTYPE html>
<html lang="en">

<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet"
      type="text/css" />
   <link rel="stylesheet" type="text/css" href="./style.css" />
   <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.min.js"></script>
   <title>SPA semplice</title>
</head>

<body>
   <div id="container" class="container">
      <div id="pagina1" class="page spazio-lg">
         <div class="row"><div><h1>Stack</h1>
            <div id="eckb-article-content-body"><h2 class="wp-block-heading" id="block-70b03cf11ed84660b1af4c7362a56811" data-id="articleTOC_0"><strong>Il modello di memoria della macchina di Von Neumann</strong></h2>
            
            
            
                <figure class="wp-block-image" id="block-07ba17f9aa83477aa1fb982c3067d83e"><img decoding="async" src="https://imagedelivery.net/IEMzXmjRvW0g933AN5ejrA/wwwnotionso-image-prod-files-secures3us-west-2amazonawscom-54c12d55-229f-4c83-b4b6-dd7d262e4443-5b0e905a-c592-41e1-8028-1a8206f05412-untitledpng/public" alt="notion image"></figure>
                
                
                
                <p>Nella macchina di Von Neumann, la memoria è organizzata come un grosso array, ovvero una sequenza di celle ciascuna con un indirizzo assoluto (da 0 alla memoria massima allocabile). La memoria massima logica di un programma è in genere data dalla sua <span class="glossaryLink" aria-describedby="tt" data-cmtooltip="<div class=glossaryItemTitle>Architettura</div><div class=glossaryItemBody>&amp;lt;!-- wp:paragraph --&amp;gt;L&amp;#039;architettura di un sistema informatico indica il modo in cui è organizzato il software, di quali componenti e moduli è composto, che ruolo hanno e in che modo comunicano.&amp;lt;br/&amp;gt;&amp;lt;!-- /wp:paragraph --&amp;gt;</div>" data-gt-translate-attributes="[{&quot;attribute&quot;:&quot;data-cmtooltip&quot;, &quot;format&quot;:&quot;html&quot;}]" tabindex="0" role="link">architettura</span>: i primi computer potevano avere pochi K di memoria, quelli moderni arrivano a decine di GB.</p>
                
                
                
                <p><strong>La memoria è unica e</strong><strong>contiene sia le istruzioni che i dati</strong>, cioè le variabili, le strutture dati, i dati di input/ouput ed ogni dato di elaborazione del programma.</p>
                
                
                
                <p>In molte implementazioni il&nbsp;<strong>codice</strong>&nbsp;viene memorizzato nella parte bassa della memoria, e ciò avviene al caricamento del programma in memoria (da parte del sistema operativo).</p>
                
                
                
                <p>Il programma in esecuzione ha pieno accesso alla memoria, e quindi può leggere e scrivere in qualsiasi locazione di memoria, conoscendone il solo indirizzo, cioè la posizione in memoria. I programmi scritti in linguaggio ad alto livello hanno comunque meccanismi di protezione della memoria, e quando vengono eseguiti forniscono al programmatore direttamente l’accesso a variabili e tipi di dato (numeri, stringhe, liste, ecc.).</p>
                
                
                
                <p>Internamente però queste variabili vengono memorizzate nell’area di memoria immediatamente “sopra” al codice, che viene chiamata “<strong>heap</strong>” (cumulo). Il programma alloca dello spazio in memoria, in base alle dimensioni delle strutture dati da utilizzare e agli algoritmi previsti da quel linguaggio ad alto livello (ad es. Java o Python).</p>
                
                
                
                <p>La memoria “in alto” invece viene utilizzata per memorizzare le chiamate ai&nbsp;<strong>sottoprogrammi</strong>&nbsp;(detti anche subroutine). I sottoprogrammi sono parti di un programma che possono essere eseguite più volte in parti diverse del programma. Essi in genere svolgono compiti di utilità e semplificano lo sviluppo di software, evitando di ripetere di scrivere lo stesso codice. Nei linguaggi ad alto livello sono chiamati in genere “funzioni”.</p>
                
                
                
                <p>Qui un esempio di chiamata di funzione (somma tra loro tutti gli interi compresi tra 1 a n):</p>
                
                
                
                <div class="hcb_wrap"><pre class="prism line-numbers  language-cpp" data-lang="C++"><code class=" language-cpp" data-hcb-clip="1"><span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                  <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    result <span class="token operator">+=</span> i<span class="token punctuation">;</span>
                  <span class="token punctuation">}</span>
                  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                 
                <span class="token keyword">int</span> s <span class="token operator">=</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><button class="hcb-clipboard" data-clipboard-target="[data-hcb-clip=&quot;1&quot;]" data-clipboard-action="copy" aria-label="Copy code to clipboard"></button></div>
                
                
                
                <p>Nella chiamata al sottoprogramma, il chiamante cede il controllo alla funzione del sottoprogramma, a cui passa eventualmente dei parametri. Alla fine tuttavia il chiamato deve restituire il controllo al chiamante, facendo eseguire l’istruzione successiva alla chiamata.</p>
                
                
                
                <figure class="wp-block-image" id="block-929ded3786d64415afdf987c3388c237"><img decoding="async" src="https://imagedelivery.net/IEMzXmjRvW0g933AN5ejrA/wwwnotionso-image-prod-files-secures3us-west-2amazonawscom-54c12d55-229f-4c83-b4b6-dd7d262e4443-7ba4473c-3f42-49c4-8b2e-fbb26e19d0d0-untitledpng/public" alt="notion image"></figure>
                
                
                
                <p>Per poter eseguire quindi le chiamate ai sottoprogrammi occorre un “meccanismo” che memorizzi sia&nbsp;<strong>l’indirizzo di ritorno</strong>&nbsp;della chiamata, sia i&nbsp;<strong>parametri</strong>&nbsp;o argomenti che questi possono ricevere. Inoltre se sono presenti vanno memorizzati anche eventuali&nbsp;<strong>valori di ritorno</strong>.</p>
                
                
                
                <p>Queste informazioni&nbsp;non si possono mettere in una posizione fissa della memoria, perchè anche un sottoprogramma ne può chiamare a sua volta un altro, e quindi deve poter anche lui memorizzare indirizzi di ritorno, parametri in ingresso e valori di ritorno. E’ necessaria una struttura dati dinamica, in memoria, che memorizzi queste informazioni, e che allo stesso tempo sia facile e veloce da utilizzare.</p>
                
                
                
                <p>Questo problema venne risolto brillantemente da Von Neumann facendo ricorso allo&nbsp;<strong>stack</strong>, una struttura matematica che si usa in programmazione.</p>
                
                
                
                <p>Vediamo di che si tratta.</p>
                
                
                
                <h2 class="wp-block-heading" id="block-982ff8432f894ad986b717d5ab3e7f30" data-id="articleTOC_1"><strong>Cos’è lo stack?</strong></h2>
                
                
                
                <p>Lo stack (“pila”) è una struttura dati matematica che si usa in informatica per memorizzare liste di elementi secondo il principio LIFO (Last In First Out). In altri termini l’accesso alla pila è solo tramite l’ultimo elemento e le due uniche operazioni possibili sono:</p>
                
                
                
                <ul class="wp-block-list" id="block-e30979bd09104a148dcc2907c2523ac3">
                <li><strong>push</strong>: aggiunta di un elemento</li>
                
                
                
                <li><strong>pop</strong>: estrazione di un elemento e sua rimozione</li>
                </ul>
                
                
                
                <p>Esempio: ipotizziamo di avere all’inizio uno stack vuoto (nessun elemento). Se eseguiamo PUSH (5) avremo:</p>
                
                
                
                <figure class="wp-block-image" id="block-d31167b3d2894a8e91c06d5da13c4956"><img decoding="async" src="https://imagedelivery.net/IEMzXmjRvW0g933AN5ejrA/wwwnotionso-image-prod-files-secures3us-west-2amazonawscom-54c12d55-229f-4c83-b4b6-dd7d262e4443-a285551c-fc09-4067-a3e5-eb7f18db4362-untitledpng/public" alt="notion image"></figure>
                
                
                
                <p>Lo stack contiene un solo elemento. Se eseguiamo una PUSH(7) avremo:</p>
                
                
                
                <figure class="wp-block-image" id="block-902dbdb2914e419cafd6a2c59748f3ff"><img decoding="async" src="https://imagedelivery.net/IEMzXmjRvW0g933AN5ejrA/wwwnotionso-image-prod-files-secures3us-west-2amazonawscom-54c12d55-229f-4c83-b4b6-dd7d262e4443-dfd007f7-0838-480f-8fd4-ff2dee3d1747-untitledpng/public" alt="notion image"></figure>
                
                
                
                <p>Ora sono due elementi. Se aggiungiamo ancora il valore 4&nbsp;&nbsp;con PUSH(4) avremo:</p>
                
                
                
                <figure class="wp-block-image" id="block-2dc42df7eb504f1b9a86ace70e58fc07"><img decoding="async" src="https://imagedelivery.net/IEMzXmjRvW0g933AN5ejrA/wwwnotionso-image-prod-files-secures3us-west-2amazonawscom-54c12d55-229f-4c83-b4b6-dd7d262e4443-4ae1974e-9d7b-4ac3-af4a-2dbeaef964c3-untitledpng/public" alt="notion image"></figure>
                
                
                
                <p>E così via. Ma attenzione, se eseguiamo POP() estrarremo l’ultimo valore (cioè 4) e rimarrà:</p>
                
                
                
                <figure class="wp-block-image" id="block-cc0c423e06194139903d3e61c50b4b47"><img decoding="async" src="https://imagedelivery.net/IEMzXmjRvW0g933AN5ejrA/wwwnotionso-image-prod-files-secures3us-west-2amazonawscom-54c12d55-229f-4c83-b4b6-dd7d262e4443-3bfdf2cd-90ef-4ca7-b2b7-5ceee4bb2c41-untitledpng/public" alt="notion image"></figure>
                
                
                
                <p>La macchina di Von Neumann prevede un registro della CPU che si chiama&nbsp;<strong>SP</strong>&nbsp;(“stack pointer”) che contiene l’indirizzo dell’ultima cella dello stack.</p>
                
                
                
                <p>Quando un programma (o sottoprogramma) ha bisogno di chiamare un sottoprogramma, memorizza nello stack :</p>
                
                
                
                <p>1)&nbsp;<strong>indirizzo di ritorno</strong>&nbsp;(PUSH)</p>
                
                
                
                <p>2)&nbsp;<strong>parametri</strong>&nbsp;opzionali (PUSH)</p>
                
                
                
                <p>E poi chiama (nella CPU si modifica il PC) il sottoprogramma.</p>
                
                
                
                <p>Il sottoprogramma esegue la sua attività, SENZA conoscere informazioni sul chiamante, ma lavorando solo sui parametri presenti nello stack.</p>
                
                
                
                <p>Al termine della sua esecuzione (quando cioè viene richiamato “return”):</p>
                
                
                
                <p>3)&nbsp;<strong>estrae</strong>&nbsp;ed&nbsp;<strong>elimina</strong>&nbsp;i&nbsp;<strong>parametri</strong>&nbsp;(POP)</p>
                
                
                
                <p>4)&nbsp;<strong>estrae indirizzo di ritorno</strong>&nbsp;(POP)</p>
                
                
                
                <p>5)&nbsp;<strong>aggiunge eventuali valori di ritorno</strong>&nbsp;(PUSH)</p>
                
                
                
                <p>6) modifica il PC e quindi l’istruzione successiva sarà quella successiva del chiamante.</p>
                
                
                
                <p>Il chiamante:</p>
                
                
                
                <p>7)&nbsp;<strong>estrae il valore di ritorno dallo stack</strong>&nbsp;(se presente) (POP)</p>
                
                
                
                <p>Lo stack (acceduto mediante SP) è quindi un meccanismo che permette di:</p>
                
                
                
                <ul class="wp-block-list" id="block-fd81cfc2da0748ee8c4e900615e52a80">
                <li>scambiare dati tra chiamante e chiamato;</li>
                
                
                
                <li>memorizzare dati&nbsp;e poterli cancellare dinamicamente quando non servono più, partendo dal più recente;</li>
                
                
                
                <li>siccome è una pila, ogni procedura in esecuzione può a sua volta chiamare delle sottoprocedure.</li>
                </ul>
                
                
                
                <p>La limitazione dello stack è ovviamente data dalla dimensione della memoria: se la memoria dello stack occupa memoria fino ad arrivare a raggiungere lo heap, succede una problematica che si chiama “stack overflow”. Di solito all’avvio del programma viene memorizzato un limite superiore alla dimensione dello stack proprio per evitare questo tipo di problema, ed alcune architetture prevedono un riconoscimento hardware.</p>
                
                
                
                <p>Qui sotto lo schema riassuntivo che mostra cosa succede allo stack in una tipica chiamata di sottoprogramma.</p>
                
                
                
                <figure class="wp-block-image" id="block-8a316f08310a42f3b03661c5fb080f96"><img decoding="async" src="https://imagedelivery.net/IEMzXmjRvW0g933AN5ejrA/wwwnotionso-image-prod-files-secures3us-west-2amazonawscom-54c12d55-229f-4c83-b4b6-dd7d262e4443-01bf541c-698d-4d57-afb1-3904d6e29e1c-untitledpng/public" alt="notion image"></figure>
               </div>
            </div>
         </div>
         <div class="row"><a href="#pagina2"><button type="button" id="pag2div1" class="btn btn-primary spazio-sm">Pagina 2 (Codice Assembly)</button></a></div>
         <div class="row"><a href="#pagina3"><button type="button" id="pag3div1" class="btn btn-primary spazio-sm">Pagina 3 (Semafori)</button></a></div>                  
   </div>
   <div id="pagina2" class="page spazio-lg">
      <div class="row"><div><h1>Codice Assembly</h1>
         <div id="eckb-article-content-body"><h2 class="wp-block-heading" data-id="articleTOC_0"><strong>Codice macchina e codice assembly</strong></h2>



         <p>In un calcolatore, <strong>le istruzioni macchina sono in codice binario</strong>. Esse vengono decodificate direttamente dalla cpu (hardware) che poi esegue le istruzioni operando sui dati (registri e memoria).&nbsp;</p>
         
         
         
         <p>Possiamo in teoria usare direttamente il linguaggio macchina (che nella quasi totalità delle implementazioni è come sappiamo in codice binario), ma per rendere questo codice comprensibile agli esseri umani, senza perdere in validità, gli sviluppatori preferiscono usare il linguaggio assembly, che da una corrispondenza delle istruzioni codice macchina con codici alfanumerici che rappresentano istruzioni, registri e valori).&nbsp;</p>
         
         
         
         <p>In questa lezione introduciamo una versione puramente didattica del linguaggio assembly, con un set limitato di istruzioni. </p>
         
         
         
         <p>Nel presentare le istruzioni si ricorda che:<br>– la CPU presenta i registri di servizio PC, IR e SP (Program Counter, Instruction Register e Stack Pointer)</p>
         
         
         
         <p>– la CPU presenta i registri dati R0… R9</p>
         
         
         
         <p>– la memoria centrale è esterna alla cpu e ci si accede per caricare/scaricare celle da/verso i registri.</p>
         
         
         
         <p>In linguaggio assembly ogni istruzione ha la forma:</p>
         
         
         
         <p><strong><code>#INDIRIZZO: CODICEISTRUZIONE operando1, operando2, operando3&nbsp;</code></strong></p>
         
         
         
         <p>dove gli operandi possono essere da 0 a 3 (a seconda dell’istruzione).</p>
         
         
         
         <p>Gli operandi possono essere:</p>
         
         
         
         <p>–&nbsp;<strong>registri</strong>: nominati con prefisso $: ad esempio $R5, prende il valore contenuto nel registro</p>
         
         
         
         <p>–&nbsp;<strong>valori assoluti</strong>: si indica il numero senza prefissi (es. “5”)</p>
         
         
         
         <p>–&nbsp;<strong>indirizzi di memoria</strong>: si indica il numero con prefisso # (es. “#250” dove 250 è l’indirizzo di una cella di memoria)</p>
         
         
         
         <p>Vediamo quindi le istruzioni:</p>
         
         
         
         <figure class="wp-block-table"><table><tbody><tr><td>Operazioni</td><td>Elenco</td></tr><tr><td>operazioni aritmetiche (somma, prodotto, ecc.) e di confronto tra operandi, eseguite dalla ALU:&nbsp;<br></td><td><strong><code>ADD, SUB, MUL, DIV</code>&nbsp;</strong>il primo operatore è dove si memorizza il risultato (sempre un registro), gli altri due sono gli operandi (possono essere o registri o valori assoluti)<br>ad esempio:&nbsp;<br><code><em>ADD $r0, 1, $r1</em>&nbsp;</code>-&gt; salva in $r0 il valore di <code>$r1 +</code><br><code><em>MULT $r5, 2, $r3</em>&nbsp;</code>-&gt; moltiplica $r3 * 2 e salva in $r5&nbsp;<strong><code>CMP</code></strong>&nbsp;(compare)<br>compara due valori.ad esempio:&nbsp;<br><em><code>CMP $r0, $r2, $r5</code></em>&nbsp;-&gt; metto in $r5 il valore 0 se sono uguali, altrimenti -1 se minore, +1 se maggiore&nbsp;</td></tr><tr><td>operazioni di controllo, ad esempio salti ad una istruzione specifica (a seconda di una condizione o liberi), eseguiti dalla CU</td><td><strong><code>JMP</code></strong>&nbsp;(salto)<br>es: <code>JMP #50</code> -&gt; salta all’indirizzo 50&nbsp;<br><strong><code>BNE</code>&nbsp;</strong>(salto condizionato su diseguaglianza)<br>es. <code>BNE $r0, 5, #81</code> -&gt; salta all’indirizzo 81 se r0 è diverso da 5&nbsp;<br><strong><code>BEQ</code></strong>&nbsp;(salto condizionato su uguaglianza)Es: <br><code>BEQ $r0, 3, $r1</code> – &gt; salto all’indirizzo contenuto nel registro r1 se r0 è uguale a 3</td></tr><tr><td>operazioni di caricamento di registri dalla memoria e viveversa, eseguiti dalla CU&nbsp;</td><td><code><strong>STO</strong>&nbsp;<strong><em>sorgente destinazione</em></strong></code>&nbsp;(save),&nbsp;<br><strong><code>LOD&nbsp;<em>destinazione</em>&nbsp;<em>sorgente</em></code></strong>&nbsp;(load)carica e salva un dato dalla memoria<br>Es:&nbsp;<br><code>STO $r0 #451</code> -&gt; memorizzo il valore di $r0 nella cella #451<br><code>LOD $r6 $r2</code> -&gt; carico il valore all’indirizzo indicato da r2 in r6</td></tr><tr><td>Subroutine</td><td><code><strong>CAL</strong>&nbsp;XXX:</code> questa istruzione salva all’indirizzo $SP l’indirizzo dell’istruzione successiva, decrementa di 1 $SP ed esegue una jump all’indirizzo XXX.<br><strong><code>RET</code></strong>&nbsp;Questa istruzione copia in $PC il valore di $SP L’istruzione gestisce da sola l’incremento dello stack pointer.&nbsp;E’ necessario l’utilizzo del registro $SP per eseguire push e pop, aggiornando la posizione dello stack dopo ogni push e pop. Si ricorda che lo stack cresce dall’alto verso il basso (quindi $SP diminuisce di 1 con push, aumenta di 1 con pop).&nbsp;<br>Es:<br><code>CAL #212 </code>-&gt; memorizza indirizzo di ritorno in stack, aggiorna lo stack pointer, ed esegue un salto all’indirizzo 212.<br><code>RET</code> -&gt; carica l’indirizzo di ritorno dallo stack, aggiorna lo stack (pop) ed esegue il salto all’istruzione indicata</td></tr></tbody></table></figure>
         
         
         
         <h2 class="wp-block-heading" data-id="articleTOC_1"><strong>Un esempio pratico</strong></h2>
         
         
         
         <p>Esempio: vogliamo memorizzare la somma degli interi da 1 a n (cioè 1+2+3+…+n).&nbsp;</p>
         
         
         
         <p>Qui il codice C++: </p>
         
         
         
         <div class="hcb_wrap"><pre class="prism line-numbers  language-plain"><code class=" language-plain" data-hcb-clip="1">int sum(int n) {&nbsp;&nbsp;
           int result = 0;&nbsp;&nbsp;
           for (int i=0; i&lt;n; i++) {&nbsp;&nbsp;&nbsp;&nbsp;
            result += i;&nbsp;&nbsp;
           }&nbsp;&nbsp;
           return result;
         }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><button class="hcb-clipboard" data-clipboard-target="[data-hcb-clip=&quot;1&quot;]" data-clipboard-action="copy" aria-label="Copy code to clipboard"></button></div>
         
         
         
         <p>Useremo i seguenti registri per memorizzare il valore delle variabili:</p>
         
         
         
         <p>$r0 -&gt; n</p>
         
         
         
         <p>$r1 -&gt; result</p>
         
         
         
         <p>$r2 -&gt; i</p>
         
         
         
         <p>$r3 -&gt; registro di servizio che useremo per gestire il ciclo</p>
         
         
         
         <p>$r8 -&gt; contiene l’indirizzo di memoria fisica dove si trova n (inserito dall’utente)</p>
         
         
         
         <p>$r9 -&gt; contiene l’indirizzo di memoria fisica dove memorizzare il risultato result alla fine</p>
         
         
         
         <p>Vediamo il codice (che ipotizziamo partire dall’indirizzo #10)</p>
         
         
         
         <div class="hcb_wrap"><pre class="prism line-numbers  language-plain"><code class=" language-plain" data-hcb-clip="2">#10: LOD $r0, $r8 carichiamo in $r0 il valore della cella di memoria il cui indirizzo è in $r8
         #11: LOD $r1, 0 carichiamo in $r1 il valore 0 (valore iniziale di result)
         #12: LOD $r2, 0 carichiamo in $r2 il valore 0 (valore iniziale di i)
         #13: ADD $r2, $r2, 1 incrementiamo $r2 di 1
         #14: ADD $r1, $r1, $r2 sommiamo a $r1 il valore di $r2
         #15: SUB $r3, $r0, $r2 memorizziamo in $r1 il risultato della sottrazione $r0 - $r2 (n-i)
         #16: BNE $r3, 0, #13 se il risultato non è 0 (cioè se n-i != 0) allora saltiamo all'istruzione #13 (3 è l'etichetta) e il ciclo ricomincia
         #17: STO $r1, $r9 memorizza nell'indirizzo di memoria indicato da $r9 il valore di $r1, cioè il risultato<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><button class="hcb-clipboard" data-clipboard-target="[data-hcb-clip=&quot;2&quot;]" data-clipboard-action="copy" aria-label="Copy code to clipboard"></button></div>
         
         
         
         <p>TPSI&nbsp;– Elenco istruzioni assembly</p>
         
         
         
         <h2 class="wp-block-heading" data-id="articleTOC_2"><strong>Elenco istruzioni con tutti gli operatori</strong></h2>
         
         
         
         <figure class="wp-block-table"><table><tbody><tr><td>Istruzione</td><td>Esempi</td><td>Significato</td></tr><tr><td colspan="3">ARITMETICO-LOGICHE</td></tr><tr><td><strong>ADD registro, operando1, operando2</strong></td><td>ADD $r0, 1, 2<br>ADD $r0, $r1, $r2<br>ADD $r0, $r1, 1</td><td>Somma.Operando1 e operando2 possono essere valori dei registri o valori assoluti</td></tr><tr><td><strong>SUB registro, operando1, operando2</strong></td><td>SUB $r0, 1, 2<br>SUB $r0, $r1, $r2<br>SUB $r0, $r1, 1</td><td>Sottrazione.Operando1 e operando2 possono essere valori dei registri o valori assoluti</td></tr><tr><td><strong>MUL registro, operando1, operando2</strong></td><td>MUL $r0, 1, 2<br>MUL $r0, $r1, $r2<br>MUL $r0, $r1, 1</td><td>Moltiplicazione.Operando1 e operando2 possono essere valori dei registri o valori assoluti</td></tr><tr><td><strong>DIV registro, operando1, operando2</strong></td><td>DIV $r0, 1, 2<br>DIV $r0, $r1, $r2<br>DIV $r0, $r1, 1</td><td>Divisione.Operando1 e operando2 possono essere valori dei registri o valori assoluti</td></tr><tr><td><strong>CMP registro, operando1, operando2</strong></td><td>CMP $r0, 1, 2<br>CMP $r0, $r1, $r2<br>CMP $r0, $r1, 1</td><td>Comparazione.&nbsp;Operando1 e operando2 possono essere valori dei registri o valori assoluti.Il risultato è:-1 se operando1 &lt; operando20 se uguali+1 se operando2 &gt; operando1</td></tr><tr><td colspan="3">SALTO</td></tr><tr><td><strong>JMP operando</strong></td><td>JMP $r0JMP #232</td><td>Salto.L’operando può essere un registro (il cui valore sarà considerato un indirizzo) o un valore assoluto.</td></tr><tr><td><strong>BNE operando1, operando2, operando3</strong></td><td>BNE $r0, $r1, #232BNE $r0, $r1, $r3BNE $r0, 5, #232BNE 3, $r1, $r1</td><td>Salto condizionato: eseguito se i valori degli operandi non sono uguali.&nbsp;Operando1 e operando2 possono essere valori dei registri o valori assoluti.Operando3 può essere un indirizzo assoluto oppure un registro (il cui valore sarà considerato un indirizzo)&nbsp;&nbsp;</td></tr><tr><td><strong>BEQ operando1, operando2, operando3</strong></td><td>BEQ $r0, $r1, #232<br>BEQ $r0, $r1, $r3<br>BEQ $r0, 5, #232<br>BNE 3, $r1, $r1</td><td>Salto condizionato: eseguito se i valori degli operandi sono uguali.&nbsp;Operando1 e operando2 possono essere valori dei registri o valori assoluti.Operando3 può essere un indirizzo assoluto oppure un registro (il cui valore sarà considerato un indirizzo)&nbsp;&nbsp;</td></tr><tr><td><strong>CAL indirizzo</strong></td><td>CAL $r0CAL #300</td><td>Esegue una push sullo stack con il valore dell’indirizzo dell’istruzione successiva, ed esegue un salto alla destinazione indicata come operando.</td></tr><tr><td><strong>RET</strong></td><td>RET</td><td>Esegue una pop dallo stack di un indirizzo, e vi esegue un salto.&nbsp;</td></tr></tbody></table></figure>
         
         
         
         <figure class="wp-block-table"><table><tbody><tr><td colspan="3">MEMORIA</td></tr><tr><td><strong>STO sorgente, destinazione</strong></td><td>STO $r0, $r1<br>STO 5, $r1<br>STO 5, #128<br>STO $r1, #421</td><td>Salva un valore in memoria.&nbsp;<br>La sorgente può essere un registro o un valore assoluto.La destinazione può essere un registro (il cui valore sarà considerato un indirizzo), o un indirizzo assoluto.</td></tr><tr><td><strong>LOD destinazione, sorgente</strong></td><td>LOD $r0, $r1<br>LOD $r1, 5<br>LOD $r2, #128</td><td>Carica un valore dalla memoria.&nbsp;<br>La sorgente può essere un registro (il cui valore sarà considerato un indirizzo), un valore assoluto o un indirizzo assoluto. La destinazione deve essere un registro.&nbsp;</td></tr></tbody></table></figure>
         
         
         
         <p>Note:</p>
         
         
         
         <p class="has-text-align-left">– $ indica il prefisso di un registro, # indica un prefisso di un indirizzo, senza prefissi è un valore assoluto;</p>
         
         
         
         <p class="has-text-align-left">– i registri della CPU sono PC (program counter), IR (istruzione corrente) e SP (indirizzo prima cella libera dello stack), ed infine R0…R9 (registri dati);</p>
         
         
         
         <p class="has-text-align-left">– si ricorda che in condizioni normali al termine di una istruzione, il PC viene incrementato di 1;</p>
         
         
         
         <p class="has-text-align-left">– l’esecuzione di una istruzione di salto consiste nel sovrascrivere il PC con l’indirizzo verso cui bisogna saltare;</p>
         
         
         
         <p class="has-text-align-left">– occorre fare attenzione al contenuto dei registri:</p>
         
         
         
         <p class="has-text-align-left">– nelle istruzioni aritmetico-logiche, il contenuto del registro è considerato un valore;</p>
         
         
         
         <p class="has-text-align-left">– nelle istruzioni di salto, quando viene usato un registro per indicare l’istruzione verso cui saltare, il valore sarà considerato un indirizzo (quindi “5” sarà considerato “#5”).</p>
         
         
         
         <p class="has-text-align-left">– nelle istruzioni di memoria, la sorgente è sempre un valore, la destinazione è sempre un indirizzo.</p>
         
         
         
         <p class="has-text-align-left">– la PUSH verso lo stack è sempre data dalla coppia di istruzioni:</p>
         
         
         
         <figure class="wp-block-table"><table><tbody><tr><td>STO $sp, value</td></tr><tr><td>SUB $sp, $sp, 1</td></tr></tbody></table></figure>
         
         
         
         <p>in quanto è necessario aggiornare SP alla prima posizione libera.</p>
         
         
         
         <p>– la PULL dallo stack è sempre data dalla coppia di istruzioni:</p>
         
         
         
         <figure class="wp-block-table"><table><tbody><tr><td>ADD $sp, $sp, 1</td></tr><tr><td>LOD $rX, $sp</td></tr></tbody></table></figure>
         
         
         
         <p>dove RX è un generico registro. E’ necessario in questo caso aggiornare SP all’ultima posizione occupata.</p>
         
         
         
         <h2 class="wp-block-heading" data-id="articleTOC_3">In conclusione</h2>
         
         
         
         <p>– per un semplice ciclo sono necessarie più operazioni a basso livello rispetto a quelle ad alto livello.&nbsp;</p>
         
         
         
         <p>– il codice macchina (di cui vediamo) è composto da istruzioni semplici e poco costose da realizzare&nbsp;</p>
         
         
         
         <p>– le istruzioni hanno lo stesso tempo di esecuzione</p>
         
         
         
         <p>Un set di istruzioni reale è molto più ampio, e si diversifica per <span class="glossaryLink" aria-describedby="tt" data-cmtooltip="<div class=glossaryItemTitle>Architettura</div><div class=glossaryItemBody>&amp;lt;!-- wp:paragraph --&amp;gt;L&amp;#039;architettura di un sistema informatico indica il modo in cui è organizzato il software, di quali componenti e moduli è composto, che ruolo hanno e in che modo comunicano.&amp;lt;br/&amp;gt;&amp;lt;!-- /wp:paragraph --&amp;gt;</div>" data-gt-translate-attributes="[{&quot;attribute&quot;:&quot;data-cmtooltip&quot;, &quot;format&quot;:&quot;html&quot;}]" tabindex="0" role="link">architettura</span>, secondo tecnologie che si sono evolute soprattutto con l’avvento dei microprocessori e le architetture moderne, come RISC e CISC (che differivano proprio per la complessità delle istruzioni) con le loro più recenti evoluzioni (X86&nbsp;&nbsp;-<span class="glossaryLink" aria-describedby="tt" data-cmtooltip="<div class=glossaryItemTitle>Tecnologia</div><div class=glossaryItemBody>&amp;lt;!-- wp:paragraph --&amp;gt;Disciplina che studia e ricerca a livello generale sia la progettazione di manufatti, sia le strategie per realizzarli. Indica inoltre le scienze applicate ai processi di trasformazione e realizzazione di prodotti. Essa è una generalizzazione della tecnica. &amp;lt;br/&amp;gt;&amp;lt;!-- /wp:paragraph --&amp;gt;&amp;lt;!-- wp:paragraph --&amp;gt;&amp;lt;br/&amp;gt;&amp;lt;!-- /wp:paragraph --&amp;gt;</div>" data-gt-translate-attributes="[{&quot;attribute&quot;:&quot;data-cmtooltip&quot;, &quot;format&quot;:&quot;html&quot;}]" tabindex="0" role="link">tecnologia</span> del mercato desktop – e ARM – <span class="glossaryLink" aria-describedby="tt" data-cmtooltip="<div class=glossaryItemTitle>Tecnologia</div><div class=glossaryItemBody>&amp;lt;!-- wp:paragraph --&amp;gt;Disciplina che studia e ricerca a livello generale sia la progettazione di manufatti, sia le strategie per realizzarli. Indica inoltre le scienze applicate ai processi di trasformazione e realizzazione di prodotti. Essa è una generalizzazione della tecnica. &amp;lt;br/&amp;gt;&amp;lt;!-- /wp:paragraph --&amp;gt;&amp;lt;!-- wp:paragraph --&amp;gt;&amp;lt;br/&amp;gt;&amp;lt;!-- /wp:paragraph --&amp;gt;</div>" data-gt-translate-attributes="[{&quot;attribute&quot;:&quot;data-cmtooltip&quot;, &quot;format&quot;:&quot;html&quot;}]" tabindex="0" role="link">tecnologia</span> del mercato mobile).</p>
         </div>
      </div>   
      <div class="row"><a href="#pagina1"><button type="button" id="pag1div2" class="btn btn-primary spazio-sm">Pagina 1 (Stack)</button></a></div>
      <div class="row"><a href="#pagina3"><button type="button" id="pag3div2" class="btn btn-primary spazio-sm">Pagina 3 (Semafori)</button></a></div>                  
      </div>
   </div>
   <div id="pagina3" class="page spazio-lg">
      <div class="row"><div><h1>Semafori</h1></div>
         <div id="eckb-article-content-body"><h2 class="wp-block-heading" data-id="articleTOC_0"><strong>Premessa</strong></h2>



            <p>Come sappiamo due funzioni in esecuzione in parallelo con memoria condivisa possono avere problemi di interferenza di sincronizzazione (dovuti a problematiche legate al tempo) e di competizione (dovuti a problematiche legate ai dati). Questo avviene sia quando siamo in uno scenario di interleaving (esecuzione concorrente) che di overlapping (esecuzione parallela).</p>
            
            
            
            <p>Dal punto di vista più formale quando si scrive una applicazione in programmazione parallela, occorre soddisfare le condizioni di Bernstein:</p>
            
            
            
            <p><strong>R(f1)&nbsp;</strong><strong>⋂&nbsp;</strong><strong>R(F2) =&nbsp;</strong><strong>∅</strong></p>
            
            
            
            <p><strong>R(F)&nbsp;</strong><strong>⋂&nbsp;</strong><strong>D(F2) =&nbsp;</strong><strong>∅</strong></p>
            
            
            
            <p><strong>D(F1)&nbsp;</strong><strong>⋂&nbsp;</strong><strong>R(F2) =&nbsp;</strong><strong>∅</strong></p>
            
            
            
            <p>dove f1 e f2 sono le due funzioni parallele, R il rango e D il dominio delle funzioni. Più semplicemente, una funzione che scrive delle variabili non può essere eseguita in parallelo di una funzione che legge o scrive lo stesso insieme di variabili.</p>
            
            
            
            <p>Compito del programmatore è quindi scrivere delle funzioni parallele che garantiscano <strong>mutua esclusione</strong> ed impediscano <strong>starvation</strong> (applicazione sempre in attesa) e <strong>deadlock</strong> (dipendenze cicliche).&nbsp;</p>
            
            
            
            <p>In conclusione le applicazioni parallele devono garantire la stessa correttezza che avrebbero se fossero eseguite come delle applicazioni sequenziali.&nbsp;</p>
            
            
            
            <h2 class="wp-block-heading" data-id="articleTOC_1"><strong>Sezione critica</strong></h2>
            
            
            
            <p>Per risolvere i problemi di parallelismo introduciamo il concetto di sezione critica.</p>
            
            
            
            <p>Una sezione critica è una particolare porzione del codice che può essere eseguita solo da un limitato numero di thread in contemporanea, o uno soltanto. Questo concetto si applica esclusivamente ad applicazioni a memoria condivisa (come i thread, ma non come i processi).</p>
            
            
            
            <p>La sezione critica garantisce quindi che una sola funzione (o un numero limitato) accedano a risorse condivise, per tutto il tempo necessario ad usare la risorsa condivisa, senza rischi di interferenza. Si veda in figura uno schema di accesso con un solo processo nella sezione critica.</p>
            
            
            
            <figure class="wp-block-image size-full"><img fetchpriority="high" decoding="async" width="632" height="556" src="https://cipiaceinfo.it/wp-content/uploads/2024/07/image-17.png" alt="" class="wp-image-243" srcset="https://cipiaceinfo.it/wp-content/uploads/2024/07/image-17.png 632w, https://cipiaceinfo.it/wp-content/uploads/2024/07/image-17-300x264.png 300w, https://cipiaceinfo.it/wp-content/uploads/2024/07/image-17-230x202.png 230w, https://cipiaceinfo.it/wp-content/uploads/2024/07/image-17-350x308.png 350w, https://cipiaceinfo.it/wp-content/uploads/2024/07/image-17-480x422.png 480w" sizes="(max-width: 632px) 100vw, 632px"></figure>
            
            
            
            <p>Sono molti gli esempi nel mondo reale che presentano una qualche analogia con il concetto di sezione critica:</p>
            
            
            
            <p>– un supermercato con una cassa: i clienti che hanno riempito il carrello in modo indipendente si devono mettere in coda alla cassa, venendo serviti uno solo alla volta. Dopo aver pagato tornano indipendenti.</p>
            
            
            
            <p>– un ufficio postale con sportelli dove occorre prendere un numero di prenotazione, ed attendere il proprio turno venendo chiamati dal primo sportello libero.</p>
            
            
            
            <p>– il casello autostradale con uno o più valichi di accesso, dove si formano code parallele per ciascuna corsia.</p>
            
            
            
            <p>Nel codice si ha una sezione critica quando più thread hanno bisogno di accedere ad una variabile condivisa, ad esempio per poter modificare quella variabile. Ipotizziamo di avere una funzione che sarà eseguita da due thread che eseguono lo stesso codice:</p>
            
            
            
            <div class="hcb_wrap"><pre class="prism line-numbers  language-cpp" data-lang="C++"><code class=" language-cpp" data-hcb-clip="1"><span class="token keyword">void</span> <span class="token function">somma</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>b<span class="token punctuation">,</span> <span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
               <span class="token keyword">int</span> sum <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token operator">*</span>b<span class="token punctuation">;</span>
               <span class="token operator">*</span>b <span class="token operator">=</span> sum<span class="token punctuation">;</span>   
            <span class="token punctuation">}</span>
            
            <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
              <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
               thread thread0 <span class="token operator">=</span> <span class="token function">thread</span><span class="token punctuation">(</span>somma<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
               thread thread1 <span class="token operator">=</span> <span class="token function">thread</span><span class="token punctuation">(</span>somma<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
               thread0<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
               thread1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
               <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><button class="hcb-clipboard" data-clipboard-target="[data-hcb-clip=&quot;1&quot;]" data-clipboard-action="copy" aria-label="Copy code to clipboard"></button></div>
            
            
            
            <p>La variabile b è letta e scritta da entrambi i thread, in istruzioni differenti. Come si può vedere il rango delle due funzioni coincide quindi ci si deve aspettare una qualche interferenza. Ad esempio potrebbe essere eseguita questa sequenza di istruzioni:</p>
            
            
            
            <figure class="wp-block-table"><table><tbody><tr><td>thread 0</td><td>&nbsp;&nbsp;&nbsp;int sum = a + *b;</td></tr><tr><td>thread 1</td><td>&nbsp;&nbsp;&nbsp;int sum = a + *b;</td></tr><tr><td>thread 1</td><td>&nbsp;&nbsp;&nbsp;*b = sum;&nbsp;&nbsp;</td></tr><tr><td>thread 0</td><td>&nbsp;&nbsp;&nbsp;*b = sum;</td></tr></tbody></table></figure>
            
            
            
            <p>Il valore finale di b sarebbe 8 mentre gli effetti dell’ultima istruzione del thread 1 completamente annullati. Un’altra esecuzione (si ricorda che lo scheduling non è deterministico) l’ordine di esecuzione delle singole istruzioni potrebbe essere:</p>
            
            
            
            <figure class="wp-block-table"><table><tbody><tr><td>thread 0</td><td>&nbsp;&nbsp;&nbsp;int sum = a + *b;</td></tr><tr><td>thread 1</td><td>&nbsp;&nbsp;&nbsp;int sum = a + *b;</td></tr><tr><td>thread 0</td><td>&nbsp;&nbsp;&nbsp;*b = sum;&nbsp;&nbsp;</td></tr><tr><td>thread 1</td><td>&nbsp;&nbsp;&nbsp;*b = sum;</td></tr></tbody></table></figure>
            
            
            
            <p>In questo caso b varrebbe 5 e sarebbe il thread 0 ad essere penalizzato. Già con un caso molto semplice, con una funzione di appena due righe di codice, possiamo avere comportamenti del tutto inaspettati. </p>
            
            
            
            <p>La sezione critica nasce per questo: impedire che l’esecuzione sia “imprevedibile” e che porti quindi a risultati diversi da quelli attesi. </p>
            
            
            
            <p>Per risolvere questo problema ci si affida ad una libreria di sistema operativo, detta semaforo. Sarà il sistema operativo che tramite il semaforo regolerà il traffico in entrata ed uscita dalla sezione critica.</p>
            
            
            
            <p>Vediamolo in dettaglio.</p>
            
            
            
            <h2 class="wp-block-heading" data-id="articleTOC_2">Mutex (o semaforo binario)</h2>
            
            
            
            <p>Il semaforo binario, detto anche mutex, è una variabile che può essere modificata da un solo thread alla volta. E’ una variabile gestita dal sistema operativo, e il thread in esecuzione non ha quindi controllo sulla scrittura del mutex. Può semplicemente cercare di acquisirlo (lock), restando in attesa se occupato, e rilasciarlo, liberandolo per il thread successivo.</p>
            
            
            
            <p>In pratica si entra nella sezione critica eseguendo un lock sul semaforo (che diventa “rosso”), si esegue la sequenza di operazioni critiche, e poi si rilascia il lock (il semaforo diventa “verde”).</p>
            
            
            
            <div class="hcb_wrap"><pre class="prism line-numbers  language-cpp" data-lang="C++"><code class=" language-cpp" data-hcb-clip="2">mutex mtx<span class="token punctuation">;</span>
            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
            
            mtx<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
            <span class="token comment">/*
            critical istructions
            */</span>
            mtx<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            
            <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><button class="hcb-clipboard" data-clipboard-target="[data-hcb-clip=&quot;2&quot;]" data-clipboard-action="copy" aria-label="Copy code to clipboard"></button></div>
            
            
            
            <p>Se un thread richiederà il semaforo mentre il primo è ancora dentro la sezione critica, lo troverà “rosso”, quindi si fermerà ed attenderà che diventi verde. E’ il sistema operativo che fornisce questa funzionalità: tutti i thread che richiedono il lock del mutex sono messi in attesa che il semaforo sia sbloccato. Inoltre il sistema operativo garantisce che l’operazione avvenga in perfetta sincronia per tutti i processori, quindi anche in caso di richiesta contemporanea di un semaforo da parte di più processori, tutte le parallelizzazioni sono sospese.&nbsp;</p>
            
            
            
            <p>Il codice precedente diventa quindi:</p>
            
            
            
            <div class="hcb_wrap"><pre class="prism line-numbers  language-cpp" data-lang="C++"><code class=" language-cpp" data-hcb-clip="3">mutex mtx<span class="token punctuation">;</span>
            
            <span class="token keyword">void</span> <span class="token function">somma</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>b<span class="token punctuation">,</span> <span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
               mtx<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
               <span class="token keyword">int</span> sum <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token operator">*</span>b<span class="token punctuation">;</span>
               <span class="token operator">*</span>b <span class="token operator">=</span> sum<span class="token punctuation">;</span>  
               mtx<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
            <span class="token punctuation">}</span>
            
            <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
              <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
               thread thread0 <span class="token operator">=</span> <span class="token function">thread</span><span class="token punctuation">(</span>somma<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
               thread thread1 <span class="token operator">=</span> <span class="token function">thread</span><span class="token punctuation">(</span>somma<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
               thread0<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
               thread1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
               <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><button class="hcb-clipboard" data-clipboard-target="[data-hcb-clip=&quot;3&quot;]" data-clipboard-action="copy" aria-label="Copy code to clipboard"></button></div>
            
            
            
            <p>Se si esegue questo codice si otterrà che solo uno dei thread potrà eseguire la somma.</p>
            
            
            
            <h2 class="wp-block-heading" data-id="articleTOC_3">Semaforo di Dijkstra (semaforo generalizzato)</h2>
            
            
            
            <p>Il&nbsp;<strong>semaforo generalizzato</strong>&nbsp;(o semaforo di&nbsp;<strong>Dijkstra</strong><a href="applewebdata://06300BE2-69BF-44EF-AFA5-C88477602ADE#_ftn1"><sup>[1]</sup></a>) è una estensione del semaforo binario che permette l’accesso alla sezione critica da parte di più di un thread alla volta. Operativamente il semaforo prevede un valore numerico (condiviso tra i thread) ed una coda di attesa. In C/C++ è gestita tramite due funzioni, P e V, che consentono l’accesso alla sezione critica ai thread.</p>
            
            
            
            <p>P: questa funzione, eseguita dal thread, richiede l’accesso alla sezione critica.</p>
            
            
            
            <div class="hcb_wrap"><pre class="prism line-numbers  language-cpp" data-lang="C++"><code class=" language-cpp" data-hcb-clip="4"><span class="token keyword">void</span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>semaphore<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
              <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>semaphore <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                unique_lock<span class="token operator">&lt;</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
                cv<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    
              <span class="token punctuation">}</span>
              <span class="token punctuation">(</span><span class="token operator">*</span>semaphore<span class="token punctuation">)</span><span class="token operator">--</span><span class="token punctuation">;</span>  
            <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><button class="hcb-clipboard" data-clipboard-target="[data-hcb-clip=&quot;4&quot;]" data-clipboard-action="copy" aria-label="Copy code to clipboard"></button></div>
            
            
            
            <p>Unique lock e wait sono funzioni di sistema operativo.<a href="applewebdata://06300BE2-69BF-44EF-AFA5-C88477602ADE#_ftn2"><sup>[2]</sup></a></p>
            
            
            
            <p>Quando un thread vuole accedere alla sezione critica esegue una operazione&nbsp;<strong>p(int *semaphore)</strong>&nbsp;dove semaphore è la variabile condivisa che contiene il numero di thread attualmente disponibili. Per prima cosa diminuisce di 1 il valore del semaforo. Se questo valore è sotto 0, il thread si mette in attesa.</p>
            
            
            
            <div class="hcb_wrap"><pre class="prism line-numbers  language-cpp" data-lang="C++"><code class=" language-cpp" data-hcb-clip="5"><span class="token keyword">void</span> <span class="token function">v</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>semaphore<span class="token punctuation">)</span> <span class="token punctuation">{</span>    
              <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>semaphore<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                cv<span class="token punctuation">.</span><span class="token function">notify_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    
              <span class="token punctuation">}</span>
              <span class="token punctuation">(</span><span class="token operator">*</span>semaphore<span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">;</span>  
            <span class="token punctuation">}</span>
            <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><button class="hcb-clipboard" data-clipboard-target="[data-hcb-clip=&quot;5&quot;]" data-clipboard-action="copy" aria-label="Copy code to clipboard"></button></div>
            
            
            
            <p>Quando un thread esce dalla sezione critica, esegue una operazione&nbsp;<strong>v(int *semaphore)</strong>&nbsp;che aumenta di 1 il valore del semaforo. Se il valore è uguale a 0, il sistema operativo toglie il primo thread in attesa in coda e lo fa entrare in sezione critica.&nbsp;</p>
            
            
            
            <p>Poniamo di avere 3 thread ed un semaforo pari a 2.&nbsp;</p>
            
            
            
            <p>Questo significa che solo 2 thread in esecuzione possono entrare nella sezione critica. Il terzo thread si metterà in coda attendendo l’uscita di un qualsiasi altro thread nella sezione critica.</p>
            
            
            
            <p>Una analogia col mondo reale è quella dell’ufficio postale, con ad esempio 3 sportelli che servono 3 persone, e una persona in attesa (col numero di prenotazione) che attende che si liberi il primo sportello.</p>
            
            
            
            <p>Qui un esempio di semaforo di valore 3.</p>
            
            
            
            <figure class="wp-block-image size-full"><img decoding="async" width="598" height="176" src="https://cipiaceinfo.it/wp-content/uploads/2024/07/image-19.png" alt="" class="wp-image-247" srcset="https://cipiaceinfo.it/wp-content/uploads/2024/07/image-19.png 598w, https://cipiaceinfo.it/wp-content/uploads/2024/07/image-19-300x88.png 300w, https://cipiaceinfo.it/wp-content/uploads/2024/07/image-19-230x68.png 230w, https://cipiaceinfo.it/wp-content/uploads/2024/07/image-19-350x103.png 350w, https://cipiaceinfo.it/wp-content/uploads/2024/07/image-19-480x141.png 480w" sizes="(max-width: 598px) 100vw, 598px"></figure>
            
            
            
            <p></p>
            
            
            
            <hr class="wp-block-separator has-alpha-channel-opacity">
            
            
            
            <p><a href="applewebdata://06300BE2-69BF-44EF-AFA5-C88477602ADE#_ftnref1"><sup>[1]</sup></a>&nbsp;Dijikstra è stato uno dei più grandi informatici, inventore oltre che del semaforo (1965) anche del più noto algoritmo che prende il suo nome (che governa la distribuzione dei pacchetti nella rete Internet) e della teoria sulla verifica formale di un algoritmo. E’ noto per aver inventato (insieme a Wirth) la programmazione strutturata e infine per i suoi aforismi, come la famosa critica alla programmazione ad oggetti.&nbsp;</p>
            
            
            
            <p><a href="applewebdata://06300BE2-69BF-44EF-AFA5-C88477602ADE#_ftnref2"><sup>[2]</sup></a>&nbsp;La condition variable è oggetto che con l’istruzione wait() ferma il thread mettendolo in una coda e con l’istruzione notify() lo riattiva.</p>
            
            
            
            <p></p>
            
            
            
            <p></p>
            </div>
         </div>
      <div class="row"><a href="#pagina1"><button type="button" id="pag1div3" class="btn btn-primary spazio-sm">Pagina 1 (Stack)</button></a></div>
      <div class="row"><a href="#pagina2"><button type="button" id="pag2div3" class="btn btn-primary spazio-sm">Pagina 3 (Semafori)</button></a></div>
   </div>
   	<div class="row">
		<div id="divHomeButton">
   			<a href="../index.html"><button type="button" id="home" class="btn btn-success btn-lg">Home</button></a>
		</div>
    </div>

  	<script type="module" src="./index.js"></script>
</body>

</html>